<!DOCTYPE html>
<html lang="en">

<head>
   <meta charset="utf-8">
   <title>Pulse of the City | Bluebikes </title>
   <script src="https://d3js.org/d3.v6.js"></script>

   <script src="https://d3js.org/d3-voronoi.v1.min.js"></script>
   <script src="https://unpkg.com/d3-simple-slider"></script>

   <script src="bubbles.js"></script>
   <script src="heatmap_slider.js"></script>
   <script src="heatmap.js"></script>
   <script src="legend.js"></script>

   <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
      integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
   <!-- Mapbox libraries -->
   <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v0.53.1/mapbox-gl.js'></script>
   <script src="https://code.jquery.com/jquery-3.3.1.min.js"
      integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
   <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v0.53.1/mapbox-gl.css' rel='stylesheet' />

   <style>
      #visOptions {
         padding-bottom: 10px;
      }
   
      #infoBoxIncomingHisto {
         margin: auto;
      }
   
      #map-container {
         height: 800px;
         width: 100%;
      }

      #station-infobox {
         min-width:300px;
      }

      div {
         display: inline-block;
      }

      div.tooltip {
         position: absolute;
         text-align: center;
         width: auto;
         height: auto;
         padding: 10px;
         font: 0.9em sans-serif;
         background-color: "white";
         border-width: "1px";
         border-color: "808080";
         border-radius: 10px;
         pointer-events: none;
         z-index: 99;

         .circle {
            fill: "3388ff";
            stroke: "3388ff";
            stroke-width: 1;
            fill-opacity: 0.4;
         }

         .stationMarker:hover {
            stroke: black;
            stroke-width: 4px;
         }
   </style>
   <style>
      .map-overlay-left {
         font-size: 0.9em;
         fill-opacity: 0.9;
         position: absolute;
         min-width:300px;
         width: 20%;
         top: 10px;
         left: 0;
         padding: 10px;
         z-index: 98;
      }

      .map-overlay-left .map-overlay-left-inner {
         border: none;
         outline: none;
         background-color: #fff;
         border-radius: 10px;
         padding: 10px;
         margin-bottom: 10px;
      }

      .map-overlay-right input {
         display: inline-block;
         width: 100%;
         position: relative;
         margin: 0;
         cursor: pointer;
      }

      .map-overlay-right {
         font-size: 0.9em;
         fill-opacity: 0.9;
         position: absolute;
         min-width:250px;
         width: 15%;
         top: 10px;
         right: 0;
         padding: 10px;
         z-index: 98;
      }

      .map-overlay-right .map-overlay-right-inner {
         background-color: #fff;
         border-radius: 10px;
         padding: 10px;
         margin-bottom: 10px;
         float: right;
      }

      #play-button {
         background: #88D840;
         padding-right: 26px;
         border-radius: 3px;
         border: none;
         color: white;
         margin: 0;
         padding: 0 12px;
         width: 60px;
         cursor: pointer;
         height: 30px;
      }

      #play-button:hover {
         background-color: #696969;
      }

      #legend-div {
         background-color: rgba(255, 255, 255, 0.514);
         border-radius: 10px;
         padding: 10px;
         margin-bottom: 10px;
         float: right;
      }
   </style>

   <style>
      .legend-circle {
         stroke: #ccc;
         stroke-dasharray: 4, 2;
         fill: none;
      }
   </style>
</head>

<body>
   <div id="map-container"></div>
   <div class="map-overlay-left">
      <div class="map-overlay-left-inner">
         <button type="button" class="map-overlay-left-inner" id="overlay-collapsible"
            onclick="toggleCollapsibleOverlay()" style="float:right">+/-</button>
         <h3>Pulse of the City | Bluebikes </h3>
         <div id="overlay-collapsible-content" style="display:block">
            <p> Bluebikes is Metro Boston's public bike share program, with more than 1,800 bikes at over 200 stations
               across Boston, Brookline, Cambridge, Somerville and Everett.
               Bluebikes is owned by the municipalities of Boston, Brookline, Cambridge, Somerville and Everett, and
               operated by Motivate.
               The team was interested in shared bikeflows, and the December 2019 data published by Bluebikes are used
               to visualize this map. </p>
         </div>
         <p style="font-size:0.8em">Data source: <a href="https://www.bluebikes.com/system-data">Bluebikes</a> by
            Motivate</p>
      </div>
      <div class="map-overlay-left-inner" id="station-infobox" style="display:none">
         <h6 id="stationInfoboxTitle"></h6>
         <div id="stationInfoboxContent"></div>
      </div>
   </div>

   <div class="map-overlay-right">
      <div class="map-overlay-right-inner">
         <h3><label id="slider-time-val"></label></h3>
         <input id="slider" type="range" min="0" max="1440" value="720">
         <label id="slider-trip-count"></label>
         <div id="vis">
            <button id="play-button">Play</button>
         </div>
      </div>
      <div class="map-overlay-right-inner" id="visOptions">
         <div><h6>Visualization options</h6>
         <button onclick="resetViews()" style="display:block">Reset views</button><br/></div>
         <div display=block>
            <label for="visualizationSettingsBubbleSize">Bubble size:
            <select id="visualizationSettingsBubbleSize">
               <option value="uniform">Uniform</option>
               <option value="trafficVolume" selected="selected">Traffic volume</option>
               <!-- <option value="tripLength">Average trip length</option> -->
               <option value="off">Off</option>
            </select></label>
         </div>
         <div display=block><label for="visualizationSettingsBubbleColor">Bubble color:
            <select id="visualizationSettingsBubbleColor">
               <option value="off">Neutral</option>
               <option value="trafficVolume" selected="selected">Traffic volume</option>
               <option value="trafficArriveDepart" selected="selected">Traffic flow</option>
            </select></label>
         </div>
         <div display=block><label for="visualizationSettingsHeatmapColor">Heatmap:
            <select id="visualizationSettingsHeatmapColor">
               <option value="off">Off</option>
               <option value="trafficVolume" selected="selected">Traffic volume</option>
               <option value="trafficArriveDepart" selected="selected">Traffic flow</option>
            </select></label><br/>
         </div>
         <svg id="legend" height=50 width=150></svg>
         <svg id="legendColorTrafficVolume" height=50 width=150></svg>
         <svg id="legendColorTrafficFlow" height=50 width=150></svg>
      </div>
      
      
   </div>

   <script>
      const FILTER_TIME_WINDOW_HOURS = 0;
      const FILTER_TIME_WINDOW_MINUTES = 120;
      const ANIMATION_DURATION = 1000;
      const BUBBLE_SIZE_DEFAULT = 8;
      const BUBBLE_COLOR_DEFAULT = "#808080";
      const HEATMAP_COLOR_DEFAULT = "hsla(0, 0%, 0%, 0.0)";

      const TRIP_DURATION_DISCARD = 2 * 60 * 60 // in seconds

      var tripsData, stationData;

      var selectedStation = {
         select(stationId) {
            this.stationId = stationId,
               this.data = stationData.find(d => d['station id'] == stationId),
               this.bubble = d3.select("#station-" + stationId),
               this.cell = d3.select("#cell-" + stationId)
         },
         clear() {
            this.stationId = null,
               this.data = null,
               this.bubble = null,
               this.cell = null
         },
         stationId: null,
         data: null,
         bubble: null,
         cell: null,
      }

      const dataOptions = {
         OFF: "off",
         UNIFORM: "uniform",
         TRAFFIC_VOLUME: "trafficVolume",
         TRAFFIC_ARR_DEP: "trafficArriveDepart",
         TRIP_LENGTH: "tripLength",
      }
      var visualizationSettings = {
         bubbleSize: dataOptions.TRAFFIC_VOLUME,
         bubbleColor: dataOptions.TRAFFIC_ARR_DEP,
         heatmapColor: dataOptions.TRAFFIC_ARR_DEP
      }
      
      colorLegendTrafficFlow();
      

      function toggleCollapsibleOverlay(collapse = false) {
         content = document.getElementById("overlay-collapsible-content");
         if (content.style.display === "block") {
            content.style.display = "none";
         } else {
            content.style.display = "block";
         }
      }
      document.getElementById("visualizationSettingsBubbleSize").addEventListener("change", function (e) {
         visualizationSettings.bubbleSize = e.target.value;
         updateMarkersAndLegend();
      });
      document.getElementById("visualizationSettingsBubbleColor").addEventListener("change", function (e) {
         visualizationSettings.bubbleColor = e.target.value;
         updateMarkersAndLegend();
      });
      document.getElementById("visualizationSettingsHeatmapColor").addEventListener("change", function (e) {
         visualizationSettings.heatmapColor = e.target.value;
         updateMarkersAndLegend();
      });
      function resetViews() {
         document.getElementById("visualizationSettingsBubbleSize").value = dataOptions.TRAFFIC_VOLUME;
         document.getElementById("visualizationSettingsBubbleColor").value = dataOptions.TRAFFIC_ARR_DEP;
         document.getElementById("visualizationSettingsHeatmapColor").value = dataOptions.TRAFFIC_ARR_DEP;
         visualizationSettings.bubbleSize = dataOptions.TRAFFIC_VOLUME;
         visualizationSettings.bubbleColor = dataOptions.TRAFFIC_ARR_DEP;
         visualizationSettings.heatmapColor = dataOptions.TRAFFIC_ARR_DEP;
         if (selectedStation.stationId != null) {
            setMarkerAppearanceUnselected(selectedStation.bubble);
         }
         selectedStation.clear();
         hideInfobox();
         updateMarkersAndLegend();
      }

      var tooltip = d3.select("body").append("div")
         .attr("class", "tooltip")
         .style("opacity", 0);

      // Draw the map
      mapboxgl.accessToken = 'pk.eyJ1IjoiY2hld3ljaGxvZSIsImEiOiJjajJiZ2g5YXQwMHYxMzJvODQxN245Z2RhIn0.ZJfu5XA9ij2_nBlZx2dcNg';
      var map = new mapboxgl.Map({
         container: 'map-container',
         style: 'mapbox://styles/mapbox/light-v10',
         center: [-71.0942, 42.3601],
         zoom: 12.5,
         minZoom: 12,
         maxZoom: 15,
      });
      // appending data to map
      var container = map.getCanvasContainer();
      var svg = d3
         .select(container)
         .append("svg")
         .attr("width", "100%")
         .attr("height", "100%")
         .style("position", "absolute")
         .style("z-index", 2);
      function project(d) {
         return map.project(new mapboxgl.LngLat(+d.longitude, +d.latitude));
      }

      // Set up other SVG groups now
      svg.insert("g", ":first-child")
         .attr("id", "stations")
      svg.insert("g", ":first-child")
         .attr("id", "heatmap")
      //.attr("fill", "none")
      
        // Color legend.
        

        
        
      // Parse the data and update markers
      d3.csv('https://raw.githubusercontent.com/6859-sp21/a4-bikerides/main/bluebikes_2020_stations.csv').then(function (csv) {
         stationData = csv;

         setUpBubbles();
         map.on("viewreset", addStationMarkers);
         map.on("move", addStationMarkers);
         map.on("moveend", addStationMarkers);

         d3.csv('https://raw.githubusercontent.com/6859-sp21/a4-bikerides/main/bluebikes_2020.csv').then(function (csv) {
            tripsDataFull = csv;

            document.getElementById('slider').addEventListener('input', handleSliderChange);
            let filterDate = updateSlider(document.getElementById("slider").value);
            
            tripsData = filterTrips(filterDate,
               FILTER_TIME_WINDOW_HOURS, FILTER_TIME_WINDOW_MINUTES);

            // Automate results via Play button
            var i = 720;
            var playButton = d3.select("#play-button");
            playButton
               .on("click", function () {
                  var button = d3.select(this);
                  if (button.text() == "Pause") {
                     moving = false;
                     clearInterval(timer);
                     // timer = 0;
                     button.text("Play");
                  } else {
                     moving = true;
                     timer = setInterval(function(e){
                        if(i==1441){
                           i = 0;
                        }
                        //updateSlider(parseInt(i))
                        document.getElementById("slider").value = i;
                        let filterDate = updateSlider(i);
                        newTripsData = filterTrips(filterDate, FILTER_TIME_WINDOW_HOURS, FILTER_TIME_WINDOW_MINUTES);
                        tripsData = newTripsData;
                        computeAllStationStats();
                        if (selectedStation.stationId == null) {
                           updateMarkers();
                        }
                        else {
                           computeStationSpecificStats(selectedStation.stationId);
                           updateMarkers();
                           setTimeout(() => { setMarkerAppearanceSelected(selectedStation.bubble) }, 1500);
                        }
                        i+=1;
                     }, 100);
                     button.text("Pause");
                  }
                  console.log("Slider moving: " + moving);
               })
            // Set up heatmap
            {
               setupHeatmap(stationData, tripsData)
               map.on("viewreset", onMapUpdate);
               map.on("move", onMapUpdate);
               map.on("moveend", onMapUpdate);
            }
            computeAllStationStats();
            updateMarkersAndLegend();

         });
      });

      function filterTrips(value, filterWindowHours, filterWindowMinutes) {
         let filterHours = value.getHours();
         let filterMinutes = value.getMinutes();
         return tripsDataFull.filter(function (trip) {
            tripStartTime = new Date(trip['starttime']);
            tripEndTime = new Date(trip['stoptime']);
            filterStartTime = new Date(tripStartTime.getTime());
            filterEndTime = new Date(tripEndTime.getTime());
            filterStartTime.setHours(filterHours - (filterWindowHours / 2));
            filterEndTime.setHours(filterHours + (filterWindowHours / 2));
            filterStartTime.setMinutes(filterMinutes - (filterWindowMinutes / 2));
            filterEndTime.setMinutes(filterMinutes + (filterWindowMinutes / 2));
            return ((tripStartTime >= filterStartTime && tripStartTime <= filterEndTime) ||
               (tripEndTime >= filterStartTime && tripEndTime <= filterEndTime));
         })
      }
      
      function updateSlider(value) {
         sliderTimeScale = d3.scaleTime()
            .domain([0, 1440])
            .range([new Date("2019-12-01 00:00"), new Date("2019-12-02 00:00")])
         let sliderTime = sliderTimeScale(value);
         document.getElementById('slider-time-val').textContent =
            sliderTime.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
         return sliderTime;
      }
      function handleSliderChange(e) {
         let filterDate = updateSlider(parseInt(e.target.value));
         newTripsData = filterTrips(filterDate, FILTER_TIME_WINDOW_HOURS, FILTER_TIME_WINDOW_MINUTES);
         tripsData = newTripsData;
         computeAllStationStats();
         if (selectedStation.stationId == null) {
            updateMarkersAndLegend();
         }
         else {
            computeStationSpecificStats(selectedStation.stationId);
            updateMarkersAndLegend();
            setTimeout(() => { setMarkerAppearanceSelected(selectedStation.bubble) },
               ANIMATION_DURATION+500);
         }
      }

      function setupInfoboxTripLengthHistogram(containerSelector1, data1, averageTripLength1, barColor1, containerSelector2, data2, averageTripLength2, barColor2) {
         console.log("setupInfoboxHisto() called with ", data1, data2)

         // convert data to minutes
         data1 = data1.map(d => d / 60)
         data2 = data2.map(d => d / 60)
         averageTripLength1 /= 60
         averageTripLength2 /= 60

         // Followed the guide here: https://www.d3-graph-gallery.com/graph/histogram_basic.html
         var margin = { top: 20, right: 30, bottom: 30, left: 40 },
            width = 300 - margin.left - margin.right,
            height = 200 - margin.top - margin.bottom;

         // Use a common x-axis domain
         var commonXAxisDomain = [0, d3.max([d3.max(data1), d3.max(data2)])]
         console.log(commonXAxisDomain)

         // Use a common y-axis domain
         var x = d3.scaleLinear()
            .domain(commonXAxisDomain) // use the same scale for both histograms
            .range([0, width])

         var histogram1 = d3.histogram()
            .value((d) => d)
            .domain(x.domain())
            .thresholds(x.ticks(15))

         var bins1 = histogram1(data1)

         var maxBinCount1 = d3.max(bins1, (d) => d.length)

         var histogram2 = d3.histogram()
            .value((d) => d)
            .domain(x.domain())
            .thresholds(x.ticks(15))

         var bins2 = histogram2(data2)

         var maxBinCount2 = d3.max(bins2, (d) => d.length)

         var y = d3.scaleLinear()
            .range([height, 0])
         y.domain([0, Math.max(maxBinCount1, maxBinCount2)])

         // Plot first histogram

         var svg = d3.select(containerSelector1)
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform",
               "translate(" + margin.left + "," + margin.top + ")")

         svg.append("g")
            .attr("transform", "translate(0, " + height + ")")
            .call(d3.axisBottom(x))

         svg.append("g")
            .call(d3.axisLeft(y))

         svg.selectAll("rect")
            .data(bins1)
            .enter()
            .append("rect")
            .attr("x", d => x(d.x0))
            .attr("width", function (d) { return x(d.x1) - x(d.x0) - 1; })
            .style("fill", barColor1)
            .style("opacity", 0.7)
            .attr("height", 0)
            .attr("y", y(0))
            .transition().duration(ANIMATION_DURATION)
            .attr("y", d => y(d.length))
            .attr("height", function (d) { return height - y(d.length); })
            .delay((d, i) => (i * 50))

         // Add line to show average length
         svg.append("line")
            .attr("x1", x(averageTripLength1))
            .attr("y1", 0)
            .attr("x2", x(averageTripLength1))
            .attr("y2", height)
            .attr("stroke", "red")
            .attr("stroke-width", 2)
         // .attr("stroke-dasharray", 4)

         svg.append("text")
            .attr("transform",
               "translate(" + (x(averageTripLength1)) + " ," +
               (-10) + ")")
            .style("text-anchor", "middle")
            .style("font-size", "smaller")
            .style("font-weight", "bold")
            .style("color", "red")
            .text(`${Math.round(averageTripLength1)} min`);

         // Add axis labels
         // Guidance: https://bl.ocks.org/d3noob/23e42c8f67210ac6c678db2cd07a747e
         svg.append("text")
            .attr("transform",
               "translate(" + (width / 2) + " ," +
               (height + margin.top + 20) + ")")
            .style("text-anchor", "middle")
            .style("font-size", "smaller")
            .text("minutes");

         svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", 0 - margin.left)
            .attr("x", 0 - (height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .style("font-size", "smaller")
            .text("# of arriving rides");




         // Plot second histogram
         // convert data to minutes
         // Followed the guide here: https://www.d3-graph-gallery.com/graph/histogram_basic.html

         // var x = d3.scaleLinear()
         //    .domain(commonXAxisDomain) // use the same scale for both histograms
         //    .range([0, width])

        

         var svg = d3.select(containerSelector1)
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform",
               "translate(" + margin.left + "," + margin.top + ")")

         svg.append("g")
            .attr("transform", "translate(0, " + height + ")")
            .call(d3.axisBottom(x))

         svg.append("g")
            .call(d3.axisLeft(y))

         svg.selectAll("rect")
            .data(bins2)
            .enter()
            .append("rect")
            .attr("x", d => x(d.x0))
            .attr("width", function (d) { return x(d.x1) - x(d.x0) - 1; })
            .style("fill", barColor2)
            .style("opacity", 0.7)
            .attr("height", 0)
            .attr("y", y(0))
            .transition().duration(ANIMATION_DURATION)
            .attr("y", d => y(d.length))
            .attr("height", function (d) { return height - y(d.length); })
            .delay((d, i) => (i * 50))

         // Add line to show average length
         svg.append("line")
            .attr("x1", x(averageTripLength2))
            .attr("y1", 0)
            .attr("x2", x(averageTripLength2))
            .attr("y2", height)
            .attr("stroke", "red")
            .attr("stroke-width", 2)
         // .attr("stroke-dasharray", 4)

         svg.append("text")
            .attr("transform",
               "translate(" + (x(averageTripLength2)) + " ," +
               (-10) + ")")
            .style("text-anchor", "middle")
            .style("font-size", "smaller")
            .style("font-weight", "bold")
            .style("color", "red")
            .text(`${Math.round(averageTripLength2)} min`);

         // Add axis labels
         // Guidance: https://bl.ocks.org/d3noob/23e42c8f67210ac6c678db2cd07a747e
         svg.append("text")
            .attr("transform",
               "translate(" + (width / 2) + " ," +
               (height + margin.top + 20) + ")")
            .style("text-anchor", "middle")
            .style("font-size", "smaller")
            .text("minutes");

         svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", 0 - margin.left)
            .attr("x", 0 - (height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .style("font-size", "smaller")
            .text("# of leaving rides");


      }

      function showInfobox() {
         collapsible = document.getElementById("overlay-collapsible-content");
         collapsible.style.display = "none";
         infobox = document.getElementById("station-infobox");
         infobox.style.display = "block";
         title = document.getElementById("stationInfoboxTitle");
         title.innerHTML = selectedStation.data['station name'];
         content = document.getElementById("stationInfoboxContent");
         let trafficVolume = +selectedStation.data.arrivals +
            selectedStation.data.departures;
         content.innerHTML = "";
         console.log("showInfobox(): ", selectedStation)
         content.innerHTML += "<p>" + trafficVolume + " riders " + "("
            + selectedStation.data.arrivals + " arriving, " +
            selectedStation.data.departures + " leaving) </p>";
         // content.innerHTML += "<p>" + selectedStation.data.males + " male riders " + "(" +
         //    ((selectedStation.data.males / trafficVolume) * 100).toFixed(2) + "%)<br/> " +
         //    selectedStation.data.females + " female riders ("
         //    + ((selectedStation.data.females / trafficVolume) * 100).toFixed(2) + "%)<br/>"
         //    + (trafficVolume - selectedStation.data.males - selectedStation.data.females)
         //    + " gender not reported (" + ((trafficVolume - selectedStation.data.males - selectedStation.data.females) / trafficVolume * 100).toFixed(2) + "%)</p>";
         // content.innerHTML += "<p>" + selectedStation.data.subscribers + " subscribers"
         //    + " (" + (selectedStation.data.subscribers / trafficVolume * 100).toFixed(2)
         //    + "%)<br/>" + (trafficVolume - selectedStation.data.subscribers) + " casual users"
         //    + " (" + ((trafficVolume - selectedStation.data.subscribers) / trafficVolume * 100).toFixed(2)
         //    + "%)</p>";
         content.innerHTML += "<p> Mean length of <b style='color:blue'> rides arriving</b>: " + Math.round(selectedStation.data.avgIncomingTripDuration / 60) + " min."
            + "<br/>Mean length of <b style='color:darkorange'>rides leaving</b>: " + Math.round(selectedStation.data.avgOutgoingTripDuration / 60) + " min."
            + "</br><small>(excluding trips longer than " + Math.round(TRIP_DURATION_DISCARD / 60 / 60) + " hrs.)</small></p>";

         content.innerHTML += "<div id='infoBoxIncomingHisto' ></div>";
         content.innerHTML += "<div id='infoBoxOutgoingHisto'></div>";

         setupInfoboxTripLengthHistogram(
            "#infoBoxIncomingHisto",
            selectedStation.data.incomingTripDurations,
            selectedStation.data.avgIncomingTripDuration,
            "blue",
            "#infoBoxOutgoingHisto",
            selectedStation.data.outgoingTripDurations,
            selectedStation.data.avgOutgoingTripDuration,
            "darkorange"
         )

         console.log("Selected station data: ", selectedStation.data)
      }
      function hideInfobox() {
         infobox = document.getElementById("station-infobox");
         infobox.style.display = "none";
      }

      function computeAllStationStats() {
         let arrivals = {}, departures = {},
            males = {}, females = {}, age = {}, subscribers = {}, durationOfIncomingTrips = {}, durationOfOutgoingTrips = {}, tmp = [];
         document.getElementById('slider-trip-count').textContent =
            tripsData.length + " trips in this time window.";


         for (var i = 0; i < tripsData.length; ++i) {
            if (!isNaN(arrivals[tripsData[i]['end station id']]))
               arrivals[tripsData[i]['end station id']]++;
            else
               arrivals[tripsData[i]['end station id']] = 1
            if (!isNaN(departures[tripsData[i]['start station id']]))
               departures[tripsData[i]['start station id']]++;
            else
               departures[tripsData[i]['start station id']] = 1

            if (tripsData[i]['gender'] == '1') {
               if (!isNaN(males[tripsData[i]['start station id']])) {
                  males[tripsData[i]['start station id']]++;
               }
               else {
                  males[tripsData[i]['start station id']] = 1;
               }
               if (!isNaN(males[tripsData[i]['end station id']])) {
                  males[tripsData[i]['end station id']]++;
               }
               else {
                  males[tripsData[i]['end station id']] = 1;
               }
            }
            else if (tripsData[i]['gender'] == '2') {
               if (!isNaN(females[tripsData[i]['start station id']])) {
                  females[tripsData[i]['start station id']]++;
               }
               else {
                  females[tripsData[i]['start station id']] = 1;
               }
               if (!isNaN(males[tripsData[i]['end station id']])) {
                  females[tripsData[i]['end station id']]++;
               }
               else {
                  females[tripsData[i]['end station id']] = 1;
               }
            }

            if (tripsData[i]['usertype'] == "Subscriber") {
               if (subscribers[tripsData[i]['start station id']] >= 0) {
                  subscribers[tripsData[i]['start station id']]++;
               }
               else {
                  subscribers[tripsData[i]['start station id']] = 1;
               }
               if (subscribers[tripsData[i]['end station id']] >= 0) {
                  subscribers[tripsData[i]['end station id']]++;
               }
               else {
                  subscribers[tripsData[i]['end station id']] = 1;
               }
            }

            let tripDuration = (tripsData[i]['tripduration'])
            let endStationID = tripsData[i]['end station id']
            let startStationID = tripsData[i]['start station id']

            if (tripDuration < TRIP_DURATION_DISCARD) {
               if (tripDuration != null) {

                  if (durationOfIncomingTrips[endStationID] == null) {
                     durationOfIncomingTrips[endStationID] = ""
                  }

                  if (durationOfOutgoingTrips[startStationID] == null) {
                     durationOfOutgoingTrips[startStationID] = ""
                  }

                  durationOfIncomingTrips[endStationID] += " " + tripDuration
                  durationOfOutgoingTrips[startStationID] += " " + tripDuration

               }
            }

         }
         stationData.forEach(function (d) {
            stationID = d['station id']

            d.arrivals = arrivals[stationID] || 0;
            d.departures = departures[stationID] || 0;
            d.males = males[stationID] || 0;
            d.females = females[stationID] || 0;
            d.subscribers = subscribers[stationID] || 0;

            let incomingTripDurationString = durationOfIncomingTrips[stationID] || ""
            d.incomingTripDurations = incomingTripDurationString.split(' ').map(s => parseInt(s))
            d.incomingTripDurations = d.incomingTripDurations.filter(v => !isNaN(v))
            d.avgIncomingTripDuration = d.incomingTripDurations.reduce((accumulator, currentValue) => accumulator + currentValue, 0) / d.incomingTripDurations.length

            let outgoingTripDurationString = durationOfOutgoingTrips[stationID] || ""
            d.outgoingTripDurations = outgoingTripDurationString.split(' ').map(s => parseInt(s))
            d.outgoingTripDurations = d.outgoingTripDurations.filter(v => !isNaN(v))
            d.avgOutgoingTripDuration = d.outgoingTripDurations.reduce((accumulator, currentValue) => accumulator + currentValue, 0) / d.outgoingTripDurations.length


            // Too slow and inefficient:
            //d.arrivals = tripsData.filter(trip => (trip['end station id'] == d['station id'])).length;
            //d.departures = tripsData.filter(trip => (trip['start station id'] == d['station id'])).length;
            //console.log(d['station id'], d.arrivals, d.departures);
         })

      }

      function computeStationSpecificStats(stationId) {
         let arrivals = {};
         let departures = {};
         stationSpecificTripsData = tripsData.filter(trip =>
            (trip['end station id'] == stationId || trip['start station id'] == stationId));


         console.log("stationSpecificsTripsData: ", stationSpecificTripsData)
         for (var i = 0; i < stationSpecificTripsData.length; ++i) {
            if (arrivals[stationSpecificTripsData[i]['end station id']] >= 0)
               arrivals[stationSpecificTripsData[i]['end station id']]++;
            else
               arrivals[stationSpecificTripsData[i]['end station id']] = 1
            if (departures[stationSpecificTripsData[i]['start station id']] >= 0)
               departures[stationSpecificTripsData[i]['start station id']]++;
            else
               departures[stationSpecificTripsData[i]['start station id']] = 1
         }


         stationData.forEach(function (d) {
            d.specificArrivals = arrivals[d['station id']] || 0;
            d.specificDepartures = departures[d['station id']] || 0;
         })

      }

      function updateMarkersAndLegend() {
         // If currently no station is selected
         if (selectedStation.stationId == null) {
            let maxTraffic = Math.max(...stationData.map(o => (o.arrivals + o.departures)), 0);
            let maxAvgDuration = Math.max(...stationData.map(o => (o.avgTripDuration)), 0);
            
            colorLegendTrafficVolume(maxTraffic);

            // Update legend
            if (visualizationSettings.bubbleSize == dataOptions.OFF) {
               d3.select("#legend").transition().duration(ANIMATION_DURATION).style("opacity", "0")

            }
            else if (visualizationSettings.bubbleSize == dataOptions.UNIFORM) {
               d3.select("#legend").transition().duration(ANIMATION_DURATION).style("opacity", "0")

            }
            else if (visualizationSettings.bubbleSize == dataOptions.TRAFFIC_VOLUME) {
               d3.select("#legend").transition().duration(ANIMATION_DURATION).style("opacity", "1")

               let legendScalingFn = function (trafficValue) {
                  return scaleRadiusTrafficVolume(trafficValue, maxTraffic)
               }

               setupLegend(maxTraffic, 3, legendScalingFn)

            }
            
            if (visualizationSettings.bubbleColor != dataOptions.TRAFFIC_VOLUME && visualizationSettings.heatmapColor != dataOptions.TRAFFIC_VOLUME) {
               d3.select("#legendColorTrafficVolume").transition().duration(ANIMATION_DURATION).style("display", "none")
            }
            else {
               d3.select("#legendColorTrafficVolume").transition().duration(ANIMATION_DURATION).style("display", "block")
            }
            
            if (visualizationSettings.bubbleColor != dataOptions.TRAFFIC_ARR_DEP && visualizationSettings.heatmapColor != dataOptions.TRAFFIC_ARR_DEP) {
               d3.select("#legendColorTrafficFlow").transition().duration(ANIMATION_DURATION).style("display", "none")
            }
            else {
               d3.select("#legendColorTrafficFlow").transition().duration(ANIMATION_DURATION).style("display", "block")
            }


            stationData.forEach(function (d) {
               let animateBubble = d3.select("#station-" + d['station id']).transition().duration(ANIMATION_DURATION);
               let animateCell = d3.select("#cell-" + d['station id']).transition().duration(ANIMATION_DURATION);

               if (visualizationSettings.bubbleSize == dataOptions.OFF) {
                  animateBubble.attr("r", 0);
               }
               else if (visualizationSettings.bubbleSize == dataOptions.UNIFORM) {
                  if ((d.arrivals + d.departures) > 0) {
                     animateBubble.attr("r", BUBBLE_SIZE_DEFAULT);
                  }
                  else {
                     animateBubble.attr("r", 0);
                  }
               }
               else if (visualizationSettings.bubbleSize == dataOptions.TRAFFIC_VOLUME) {
                  let newRadius = scaleRadiusTrafficVolume(d.arrivals + d.departures, maxTraffic)
                  animateBubble.attr("r", newRadius);
               } else if (visualizationSettings.bubbleSize == dataOptions.TRIP_LENGTH) {
                  console.log("TRIP LENGTH: ", d.avgTripDuration, maxAvgDuration)
                  let newRadius = scaleRadiusTrafficVolume(Math.max(0, d.avgTripDuration), maxAvgDuration)
                  animateBubble.attr("r", newRadius);
               }

               if (visualizationSettings.bubbleColor == dataOptions.OFF) {
                  animateBubble.style("fill", BUBBLE_COLOR_DEFAULT).attr("stroke", BUBBLE_COLOR_DEFAULT);
               }
               else if (visualizationSettings.bubbleColor == dataOptions.TRAFFIC_VOLUME) {
                  let newColor = scaleColorTrafficVolume(d.arrivals + d.departures);
                  animateBubble.style("fill", newColor).attr("stroke", newColor);
               }
               else if (visualizationSettings.bubbleColor == dataOptions.TRAFFIC_ARR_DEP) {
                  let newColor = scaleColorTrafficArriveDepart(d.arrivals, d.departures);
                  animateBubble.style("fill", newColor).attr("stroke", newColor);
               }

               if (visualizationSettings.heatmapColor == dataOptions.OFF) {
                  console.log("heatmap off");
                  animateCell.style("fill", HEATMAP_COLOR_DEFAULT);
               }
               else if (visualizationSettings.heatmapColor == dataOptions.TRAFFIC_VOLUME) {
                  let newColor = scaleColorTrafficVolume(d.arrivals + d.departures);
                  animateCell.style("fill", newColor).attr("fill-opacity", 0.3);
               }
               else if (visualizationSettings.heatmapColor == dataOptions.TRAFFIC_ARR_DEP) {
                  let newColor = scaleColorTrafficArriveDepart(d.arrivals, d.departures);
                  animateCell.style("fill", newColor).attr("fill-opacity", 0.1);
               }
            })
         }
         // If there is currently a station selected
         else {
            let maxTraffic = Math.max(...stationData.map(o => (o.specificArrivals + o.specificDepartures)), 0);
            
            colorLegendTrafficVolume(maxTraffic);


            console.log("selected station: ", selectedStation)
            let stationsMinusSelected = stationData.filter(d => d["station id"] != selectedStation.stationId)
            console.log("stationsMinusSelected: ", stationsMinusSelected)
            let maxTrafficMinusSelected = Math.max(...stationsMinusSelected.map(o => (o.specificArrivals + o.specificDepartures)), 0);

            // Update legend
            if (visualizationSettings.bubbleSize == dataOptions.OFF) {
               d3.select("#legend").transition().duration(ANIMATION_DURATION).style("opacity", "0")

            }
            else if (visualizationSettings.bubbleSize == dataOptions.UNIFORM) {
               d3.select("#legend").transition().duration(ANIMATION_DURATION).style("opacity", "0")

            }
            else if (visualizationSettings.bubbleSize == dataOptions.TRAFFIC_VOLUME) {
               d3.select("#legend").transition().duration(ANIMATION_DURATION).style("opacity", "1")

               let legendScalingFn = function (trafficValue) {
                  return scaleRadiusStationTrafficVolume(trafficValue, maxTraffic)
               }
               
            if (visualizationSettings.bubbleColor != dataOptions.TRAFFIC_VOLUME && visualizationSettings.heatmapColor != dataOptions.TRAFFIC_VOLUME) {
               d3.select("#legendColorTrafficVolume").transition().duration(ANIMATION_DURATION).style("display", "none")
            }
            else {
               d3.select("#legendColorTrafficVolume").transition().duration(ANIMATION_DURATION).style("display", "block")
            }
            
            if (visualizationSettings.bubbleColor != dataOptions.TRAFFIC_ARR_DEP && visualizationSettings.heatmapColor != dataOptions.TRAFFIC_ARR_DEP) {
               d3.select("#legendColorTrafficFlow").transition().duration(ANIMATION_DURATION).style("display", "none")
            }
            else {
               d3.select("#legendColorTrafficFlow").transition().duration(ANIMATION_DURATION).style("display", "block")
            }


               console.log("setup legend: max traffic", maxTraffic)
               console.log("setup legend: max traffic minus selected", maxTrafficMinusSelected)
               setupLegend(maxTrafficMinusSelected, 2, legendScalingFn)

            }

            stationData.forEach(function (d) {
               let animateBubble = d3.select("#station-" + d['station id']).transition().duration(ANIMATION_DURATION);
               let animateCell = d3.select("#cell-" + d['station id']).transition().duration(ANIMATION_DURATION);

               if (visualizationSettings.bubbleSize == dataOptions.OFF) {
                  animateBubble.attr("r", 0);
               }
               else if (visualizationSettings.bubbleSize == dataOptions.UNIFORM) {
                  if ((d.specificArrivals + d.specificDepartures) > 0) {
                     animateBubble.attr("r", BUBBLE_SIZE_DEFAULT);
                  }
                  else {
                     animateBubble.attr("r", 0);
                  }
               }
               else if (visualizationSettings.bubbleSize == dataOptions.TRAFFIC_VOLUME) {
                  let newRadius = scaleRadiusStationTrafficVolume(d.specificArrivals + d.specificDepartures, maxTraffic)
                  animateBubble.attr("r", newRadius);
               }

               if (visualizationSettings.bubbleColor == dataOptions.OFF) {
                  animateBubble.style("fill", BUBBLE_COLOR_DEFAULT).attr("stroke", BUBBLE_COLOR_DEFAULT);
               }
               if (visualizationSettings.bubbleColor == dataOptions.TRAFFIC_VOLUME) {
                  let newColor = scaleColorTrafficVolume(d.specificArrivals + d.specificDepartures);
                  animateBubble.style("fill", newColor).attr("stroke", newColor);
               }
               if (visualizationSettings.bubbleColor == dataOptions.TRAFFIC_ARR_DEP) {
                  let newColor = scaleColorTrafficArriveDepart(d.specificArrivals, d.specificDepartures);
                  animateBubble.style("fill", newColor).attr("stroke", newColor);
               }

               if (visualizationSettings.heatmapColor == dataOptions.OFF) {
                  animateCell.style("fill", HEATMAP_COLOR_DEFAULT);
               }
               else if (visualizationSettings.heatmapColor == dataOptions.TRAFFIC_VOLUME) {
                  let newColor = scaleColorTrafficVolume(d.specificArrivals + d.specificDepartures, maxTraffic);
                  animateCell.style("fill", newColor).attr("fill-opacity", 0.3);
               }
               else if (visualizationSettings.heatmapColor == dataOptions.TRAFFIC_ARR_DEP) {
                  let newColor = scaleColorTrafficArriveDepart(d.specificArrivals, d.specificDepartures);
                  animateCell.style("fill", newColor).attr("fill-opacity", 0.1);
               }
            })
            showInfobox();
            setTimeout(() => { setMarkerAppearanceSelected(selectedStation.bubble) }, ANIMATION_DURATION + 100);
         }

      }

      function scaleRadiusTrafficVolume(traffic, maxTraffic = 500) {
         let newRadius = 0;
         let radiusDomain = Math.max(maxTraffic, 500);
         scaleRadius = d3.scaleSqrt()
            .domain([0, 1, radiusDomain])
            .range([0, 3, 20]);
         newRadius = scaleRadius(traffic);
         return newRadius;
      }

      function scaleRadiusStationTrafficVolume(traffic, maxTraffic = 100) {
         let newRadius = 0
         scaleRadius = d3.scaleSqrt()
            .domain([0, 1, maxTraffic / 5])
            .range([0, 3, 15]);

         newRadius = Math.min(scaleRadius(traffic), 20);
         return newRadius;
      }

      function scaleColorTrafficVolume(traffic, maxTraffic = 800) {
         let newColor = HEATMAP_COLOR_DEFAULT;
         let trafficVolumeScale = d3.scaleLinear()
            .domain([0, maxTraffic])
            .range(['lightblue', 'blue']);
         if (traffic > 0) {
            newColor = trafficVolumeScale(traffic);
         }
         return newColor;
      }

      function scaleColorTrafficArriveDepart(arrivals, departures) {
         let newColor = HEATMAP_COLOR_DEFAULT;
         scaleColor = d3.scaleLinear()
            .domain([0, 0.35, 0.65, 1])
            .range(['darkorange', 'orange', 'blue', 'darkblue']);
         if (!isNaN(arrivals) && !isNaN(departures)) {
            newColor = scaleColor(arrivals * 1.0 / (arrivals + departures));
         }
         return newColor;
      }
      
      function colorLegendTrafficVolume(maxTraffic) {
         d3.select("#legendColorTrafficVolume").selectAll("*").remove();
         let width = 150;
         let barHeight = 8;
         let height = 30;
         let xTicks = [0, maxTraffic/2, maxTraffic];
         let padding = 9;
         var innerWidth = width - (padding * 2);
         
         let xScale = d3.scaleLinear()
              .range([0, innerWidth])
              .domain([0, maxTraffic]);
           
           var xAxis = d3.axisBottom(xScale)
              .tickSize(barHeight * 2)
              .tickValues(xTicks);
         
         let svg = d3.select("#legendColorTrafficVolume").attr("width", 150).attr("height", 30);
         let g = svg.append("g").attr("transform", "translate(" + padding + ", 0)");;
         let defs = svg.append("defs");
         let linearGradient = defs.append("linearGradient").attr("id", "TrafficVolumeGradient");
         linearGradient.append("stop").attr("offset", "0%").attr("stop-color", 'lightblue')
         linearGradient.append("stop").attr("offset", "100%").attr("stop-color", 'darkblue');
         //svg.append("text").attr("text-anchor", "middle").attr("x", 75).attr("y", 10)
         //   .text("Traffic volume").style("font-size", "0.8em").style("font-weight", "bold");
         g.append("rect").attr("width", innerWidth).attr("height", 8).attr("x", 0).attr("y", 10)
           .style("fill", "url(#TrafficVolumeGradient)").attr("fill-opacity", 0.5);
         g.append("g").call(xAxis).select(".domain").remove();
      }
      
      function colorLegendTrafficFlow() {
         
         d3.select("#legendColorTrafficFlow").selectAll("*").remove();
         let width = 150;
         let barHeight = 8;
         let height = 30;
         let padding = 9;
         var innerWidth = width - (padding * 2);
         
         let svg = d3.select("#legendColorTrafficFlow").attr("width", 150).attr("height", 45);
         let g = svg.append("g");
         let defs = svg.append("defs");
         let linearGradient = defs.append("linearGradient").attr("id", "TrafficFlowGradient");
         linearGradient.append("stop").attr("offset", "0%").attr("stop-color", 'darkorange')
         linearGradient.append("stop").attr("offset", "35%").attr("stop-color", 'orange');
         linearGradient.append("stop").attr("offset", "65%").attr("stop-color", 'blue');
         linearGradient.append("stop").attr("offset", "100%").attr("stop-color", 'darkblue');
         svg.append("text").attr("text-anchor", "end").attr("x", 150).attr("y", 40)
            .text("Arriving").style("font-size", "0.8em");
         svg.append("text").attr("text-anchor", "start").attr("x", 0).attr("y", 40)
            .text("Leaving").style("font-size", "0.8em");
         //svg.append("text").attr("text-anchor", "middle").attr("x", 75).attr("y", 10)
         //   .text("Traffic flow").style("font-size", "0.8em").style("font-weight", "bold");
         g.append("rect").attr("width", width).attr("height", 8).attr("x", 0).attr("y", 20)
           .style("fill", "url(#TrafficFlowGradient)").attr("fill-opacity", 0.5);
         //g.append("g").call(xAxis).select(".domain").remove();
      }
      

   </script>

</body>

</html>