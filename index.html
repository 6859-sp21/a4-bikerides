<!DOCTYPE html>
<html lang="en">

<head>
   <meta charset="utf-8">
   <title>Pulse of the City | Blue Bikes </title>
   <script src="https://d3js.org/d3.v6.js"></script>
   
   <script src="https://d3js.org/d3-voronoi.v1.min.js"></script>
   <script src="https://unpkg.com/d3-simple-slider"></script>
   
   <script src="bubbles.js"></script>
   <script src="heatmap_slider.js"></script>
   <script src="heatmap.js"></script>

   <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
      integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
   <!-- Mapbox libraries -->
   <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v0.53.1/mapbox-gl.js'></script>
   <script src="https://code.jquery.com/jquery-3.3.1.min.js"
      integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
   <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v0.53.1/mapbox-gl.css' rel='stylesheet' />

   <style>
      #map-container {
         height: 800px;
         width: 100%;
      }

      div {
         display: inline-block;
      }

      div.tooltip {
         position: absolute;
         text-align: center;
         width: auto;
         height: auto;
         padding: 10px;
         font: 0.9em sans-serif;
         background-color: "white";
         border-width: "1px";
         border-color: "808080";
         border-radius: 10px;
         pointer-events: none;
         z-index: 99;

         .circle {
            fill: "3388ff";
            stroke: "3388ff";
            stroke-width: 1;
            fill-opacity: 0.4;
         }

         .stationMarker:hover {
            stroke: black;
            stroke-width: 4px;
         }
   </style>
   <style>
      .map-overlay-left {
      font-size:0.9em;
      fill-opacity: 0.9;
      position: absolute;
      width: 25%;
      top: 10px;
      left: 0;
      padding: 10px;
      z-index: 98;
      }
      .map-overlay-left .map-overlay-left-inner {
      background-color: #fff;
      border-radius: 10px;
      padding: 10px;
      margin-bottom: 10px;
      }

      .map-overlay-right input {
      display: inline-block;
      width: 100%;
      position: relative;
      margin: 0;
      cursor: pointer;
      }
      .map-overlay-right {
      font-size:0.9em;
      fill-opacity: 0.9;
      position: absolute;
      width: 20%;
      top: 10px;
      right: 0;
      padding: 10px;
      z-index: 98;
      }
      .map-overlay-right .map-overlay-right-inner {
      background-color: #fff;
      border-radius: 10px;
      padding: 10px;
      margin-bottom: 10px;
      float: right;
      }

      #play-button {
      background: #88D840;
      padding-right: 26px;
      border-radius: 3px;
      border: none;
      color: white;
      margin: 0;
      padding: 0 12px;
      width: 60px;
      cursor: pointer;
      height: 30px;
    }

    #play-button:hover {
      background-color: #696969;
    }
    
   </style>
</head>

<body>
   <div id="map-container"></div>
   <div class="map-overlay-left">
      <div class="map-overlay-left-inner">
         <br>
         <h3>Pulse of the City | Blue Bikes </h3></br>
         <p> Bluebikes is Metro Boston's public bike share program, with more than 1,800 bikes at over 200 stations
            across Boston, Brookline, Cambridge, Somerville and Everett.
            Bluebikes is owned by the municipalities of Boston, Brookline, Cambridge, Somerville and Everett, and
            operated by Motivate.
            The team was interested in shared bikeflows, and how that changed during the pandemic. December 2019 and
            2020 data published by Bluebikes are used to visualize this map. </p>
         <p><b>Circle sizes</b> indicate the overall volume of traffic at each bike station.</p>

         <p><b>Colors</b> indicate the relative proportions of people <b style="color:blue">arriving</b> and <b
               style="color:darkorange">leaving</b> each station.</p>

         <p><b>Click on a station</b> to view traffic at all stations originating or terminating at the selected
            station. Circles are rescaled and recolored to show the volume of riders for each station that are <b
               style="color:blue">arriving</b> at or <b style="color:darkorange">leaving</b> the selected station.
         </p>
      </div>
   </div>
   <div class="map-overlay-right">
      <div class="map-overlay-right-inner" >
         <h4><label id="slider-time-val"></label></h4>
         <input id="slider" type="range" min="0" max="1440" value="720">
         <label id="slider-trip-count"></label>
      <div id="vis">
            <button id="play-button">Play</button>
      </div>
      </div>
      <div class="map-overlay-right-inner" >
         <div display=block>
         <label for="visualizationSettingsBubbleSize">Bubble size:</label>
         <select id="visualizationSettingsBubbleSize">
         <option value="off">Remove bubbles</option>
        <option value="uniform">Uniform</option>
        <option value="trafficVolume" selected="selected">Traffic volume</option>
        </select></div>
         <div display=block><label for="visualizationSettingsBubbleColor">Bubble color:</label>
         <select id="visualizationSettingsBubbleColor">
        <option value="off">Neutral</option>
        <option value="trafficArriveDepart" selected="selected">Traffic flow</option>
    </select></div>
      <div display=block><label for="visualizationSettingsHeatmapColor">Heatmap color:</label>
         <select id="visualizationSettingsHeatmapColor">
        <option value="off">Off</option>
        <option value="trafficArriveDepart" selected="selected">Traffic flow</option>
    </select></div>
      </div>
   </div>

        <script>
            const FILTER_TIME_WINDOW_HOURS = 0;
            const FILTER_TIME_WINDOW_MINUTES = 120;
            const ANIMATION_DURATION = 1000;
            const BUBBLE_SIZE_DEFAULT = 10;
            const BUBBLE_COLOR_DEFAULT = "#808080";
            const HEATMAP_COLOR_DEFAULT = "hsla(0, 0%, 0%, 0.0)";

            var tripsData, stationData;
            
            var selectedStation = {
               select(stationId) {
                  this.stationId = stationId,
                  this.data = stationData.find(d => d.stationId == stationId),
                  this.bubble = d3.select("#station-"+stationId),
                  this.cell = d3.select("#cell-"+stationId)
               },
               clear() {
                  this.stationId = null,
                  this.data = null,
                  this.bubble = null,
                  this.cell = null
               },
               stationId : null,
               data : null,
               bubble : null,
               cell : null,
            }
            
            const dataOptions = {
               OFF: "off",
            	UNIFORM: "uniform",
            	TRAFFIC_VOLUME: "trafficVolume",
            	TRAFFIC_ARR_DEP: "trafficArriveDepart",
            }
            var visualizationSettings = {
               bubbleSize: dataOptions.TRAFFIC_VOLUME,
               bubbleColor: dataOptions.TRAFFIC_ARR_DEP,
               heatmapColor: dataOptions.TRAFFIC_ARR_DEP
            }
            
            document.getElementById("visualizationSettingsBubbleSize").addEventListener("change", function (e) {
                  visualizationSettings.bubbleSize = e.target.value;
                  updateMarkers();
               });
            document.getElementById("visualizationSettingsBubbleColor").addEventListener("change", function (e) {
                  visualizationSettings.bubbleColor = e.target.value;
                  updateMarkers();
               });
            document.getElementById("visualizationSettingsHeatmapColor").addEventListener("change", function (e) {
                  visualizationSettings.heatmapColor = e.target.value;
                  updateMarkers();
               });
            
            var tooltip = d3.select("body").append("div")
               .attr("class", "tooltip")
               .style("opacity", 0);

            // Draw the map
            mapboxgl.accessToken = 'pk.eyJ1IjoiY2hld3ljaGxvZSIsImEiOiJjajJiZ2g5YXQwMHYxMzJvODQxN245Z2RhIn0.ZJfu5XA9ij2_nBlZx2dcNg';
            var map = new mapboxgl.Map({
               container: 'map-container',
               style: 'mapbox://styles/mapbox/light-v10',
               center: [-71.0942,42.3601],
               zoom: 12.5,
               minZoom: 12,
               maxZoom: 15,
            });
            // appending data to map
            var container = map.getCanvasContainer();
            var svg = d3
              .select(container)
              .append("svg")
              .attr("width", "100%")
              .attr("height", "100%")
              .style("position", "absolute")
              .style("z-index", 2);
              
            function project(d) {
              return map.project(new mapboxgl.LngLat(+d.longitude, +d.latitude));
            }
            
            // Set up other SVG groups now
            svg.insert("g", ":first-child")
               .attr("id", "stations")
            svg.insert("g", ":first-child")
               .attr("id", "heatmap")
               //.attr("fill", "none")
            
            // Parse the data and update markers
            d3.csv('https://raw.githubusercontent.com/6859-sp21/a4-bikerides/main/bluebikes_2020_stations.csv').then(function(csv)  {
                  stationData = csv;

               setUpBubbles();
               map.on("viewreset", addStationMarkers);
               map.on("move", addStationMarkers);
               map.on("moveend", addStationMarkers);
               
               d3.csv('https://raw.githubusercontent.com/6859-sp21/a4-bikerides/main/bluebikes_2020.csv').then(function(csv) {
                  tripsDataFull = csv;
                  
                  function updateSlider(value) {
                     sliderTimeScale = d3.scaleTime()
                       .domain([0, 1440])
                       .range([new Date("2019-12-01 00:00"), new Date("2019-12-02 00:00")])
                     let sliderTime = sliderTimeScale(value);
                     document.getElementById('slider-time-val').textContent =
                        sliderTime.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
                     return sliderTime;
                  }
                  document
                     .getElementById('slider')
                     .addEventListener('input', function (e) {
                        let value = parseInt(e.target.value);
                        let filterDate = updateSlider(value);
                        newTripsData = filterTrips(filterDate, FILTER_TIME_WINDOW_HOURS, FILTER_TIME_WINDOW_MINUTES);
                        tripsData = newTripsData;
                        computeTotalTraffic();
                        if (selectedStation.stationId == null) {
                           updateMarkers();
                        }
                        else {
                           computeStationOnlyTraffic(selectedStation.stationId);
                           updateMarkers();
                           setTimeout(() => { setMarkerAppearanceSelected(selectedStation.bubble) }, 1500);
                        }
                     });

               let filterDate = updateSlider(document.getElementById("slider").value);
               tripsData = filterTrips(filterDate, FILTER_TIME_WINDOW_HOURS, FILTER_TIME_WINDOW_MINUTES);
               
               // Automate results via Play button
               var playButton = d3.select("#play-button");
                     playButton
                        .on("click", function() {
                        var button = d3.select(this);
                        if (button.text() == "Pause") {
                           moving = false;
                           clearInterval(timer);
                           // timer = 0;
                           button.text("Play");
                        } else {
                           moving = true;
                           timer = setInterval(step, 100);
                           button.text("Pause");
                        }
                        console.log("Slider moving: " + moving);
                     })

                  // Set up heatmap
                  {
                     setupHeatmap(stationData, tripsData)
                     map.on("viewreset", onMapUpdate);
                     map.on("move", onMapUpdate);
                     map.on("moveend", onMapUpdate);
                  }
                  computeTotalTraffic();
                  updateMarkers();
               });
            });
            
            function filterTrips(value, filterWindowHours, filterWindowMinutes) {
               let filterHours = value.getHours();
               let filterMinutes = value.getMinutes();
               return tripsDataFull.filter(function(trip) {
                  tripStartTime = new Date(trip['starttime']);
                  tripEndTime = new Date(trip['stoptime']);
                  filterStartTime = new Date(tripStartTime.getTime());
                  filterEndTime = new Date(tripEndTime.getTime());
                  filterStartTime.setHours(filterHours-(filterWindowHours/2));
                  filterEndTime.setHours(filterHours+(filterWindowHours/2));
                  filterStartTime.setMinutes(filterMinutes-(filterWindowMinutes/2));
                  filterEndTime.setMinutes(filterMinutes+(filterWindowMinutes/2));
                  return ((tripStartTime >= filterStartTime && tripStartTime <= filterEndTime) ||
                     (tripEndTime >= filterStartTime && tripEndTime <= filterEndTime));
               })
            }
            
            function computeTotalTraffic() {
               var arrivals = {};
               var departures = {};
               document.getElementById('slider-trip-count').textContent =
                        tripsData.length + " trips in this time window.";
               for(var i = 0; i < tripsData.length; ++i){
                   if (arrivals[tripsData[i]['end station id']] >= 0)
                     arrivals[tripsData[i]['end station id']]++;
                  else
                     arrivals[tripsData[i]['end station id']] = 1
                  if (departures[tripsData[i]['start station id']] >= 0)
                     departures[tripsData[i]['start station id']]++;
                  else
                     departures[tripsData[i]['start station id']] = 1
               }
               stationData.forEach(function(d) {
                  d.arrivals = arrivals[ d['station id'] ] || 0;
                  d.departures = departures[ d['station id'] ] || 0;
               // Too slow and inefficient:
                //d.arrivals = tripsData.filter(trip => (trip['end station id'] == d['station id'])).length;
                //d.departures = tripsData.filter(trip => (trip['start station id'] == d['station id'])).length;
                //console.log(d['station id'], d.arrivals, d.departures);
               })
               
            }
            
            function computeStationOnlyTraffic(stationId) {
               var arrivals = {};
               var departures = {};
               stationSpecificTripsData = tripsData.filter(trip =>
                  (trip['end station id'] == stationId || trip['start station id'] == stationId));
               for(var i = 0; i < stationSpecificTripsData.length; ++i){
                   if (arrivals[stationSpecificTripsData[i]['end station id']] >= 0)
                     arrivals[stationSpecificTripsData[i]['end station id']]++;
                  else
                     arrivals[stationSpecificTripsData[i]['end station id']] = 1
                  if (departures[stationSpecificTripsData[i]['start station id']] >= 0)
                     departures[stationSpecificTripsData[i]['start station id']]++;
                  else
                     departures[stationSpecificTripsData[i]['start station id']] = 1
               }
               stationData.forEach(function(d) {
                  d.specificArrivals = arrivals[ d['station id'] ] || 0;
                  d.specificDepartures = departures[ d['station id'] ] || 0;
               })
               
            }
            
            function updateMarkers() {
               if (selectedStation.stationId == null) {
                  let maxTraffic = Math.max(...stationData.map(o => (o.arrivals + o.departures) ), 0);
                  stationData.forEach(function(d) {
                     let animateBubble = d3.select("#station-"+d['station id']).transition().duration(ANIMATION_DURATION);
                     let animateCell = d3.select("#cell-"+d['station id']).transition().duration(ANIMATION_DURATION);
                     
                     if (visualizationSettings.bubbleSize == dataOptions.OFF) {
                        animateBubble.attr("r", 0);
                     }
                     else if (visualizationSettings.bubbleSize == dataOptions.UNIFORM) {
                        if ((d.arrivals + d.departures) > 0) {
                           animateBubble.attr("r", BUBBLE_SIZE_DEFAULT);
                        }
                        else {
                           animateBubble.attr("r", 0);
                        }
                     }
                     else if (visualizationSettings.bubbleSize == dataOptions.TRAFFIC_VOLUME) {
                        let newRadius = scaleRadiusTrafficVolume(d.arrivals + d.departures, maxTraffic)
                        animateBubble.attr("r", newRadius);
                     }
                     
                     if (visualizationSettings.bubbleColor == dataOptions.OFF) {
                        animateBubble.style("fill", BUBBLE_COLOR_DEFAULT).attr("stroke", BUBBLE_COLOR_DEFAULT);
                     }
                     else if (visualizationSettings.bubbleColor == dataOptions.TRAFFIC_ARR_DEP) {
                        let newColor = scaleColorTrafficArriveDepart(d.arrivals, d.departures);
                        animateBubble.style("fill", newColor).attr("stroke", newColor);
                     }
                     
                     if (visualizationSettings.heatmapColor == dataOptions.OFF) {
                        console.log("heatmap off");
                        animateCell.style("fill", HEATMAP_COLOR_DEFAULT);
                     }
                     else if (visualizationSettings.heatmapColor == dataOptions.TRAFFIC_ARR_DEP) {
                        let newColor = scaleColorTrafficArriveDepart(d.arrivals, d.departures);
                        animateCell.style("fill", newColor);
                     }
                  })
               }
               else {
                  let maxTraffic = Math.max(...stationData.map(o => (o.specificArrivals + o.specificDepartures) ), 0);
                  stationData.forEach(function(d) {
                     let animateBubble = d3.select("#station-"+d['station id']).transition().duration(ANIMATION_DURATION);
                     let animateCell = d3.select("#cell-"+d['station id']).transition().duration(ANIMATION_DURATION);
                     
                     if (visualizationSettings.bubbleSize == dataOptions.OFF) {
                        animateBubble.attr("r", 0);
                     }
                     else if (visualizationSettings.bubbleSize == dataOptions.UNIFORM) {
                        if ((d.specificArrivals + d.specificDepartures) > 0) {
                           animateBubble.attr("r", BUBBLE_SIZE_DEFAULT);
                        }
                        else {
                           animateBubble.attr("r", 0);
                        }
                     }
                     else if (visualizationSettings.bubbleSize == dataOptions.TRAFFIC_VOLUME) {
                        let newRadius = scaleRadiusStationTrafficVolume(d.specificArrivals + d.specificDepartures, maxTraffic)
                        animateBubble.attr("r", newRadius);
                     }
                     
                     if (visualizationSettings.bubbleColor == dataOptions.OFF) {
                        animateBubble.style("fill", BUBBLE_COLOR_DEFAULT).attr("stroke", BUBBLE_COLOR_DEFAULT);
                     }
                     if (visualizationSettings.bubbleColor == dataOptions.TRAFFIC_ARR_DEP) {
                        
                        let newColor = scaleColorTrafficArriveDepart(d.specificArrivals, d.specificDepartures);
                        animateBubble.style("fill", newColor).attr("stroke", newColor);
                     }
                     
                     if (visualizationSettings.heatmapColor == dataOptions.OFF) {
                        animateCell.style("fill", HEATMAP_COLOR_DEFAULT);
                     }
                     else if (visualizationSettings.heatmapColor == dataOptions.TRAFFIC_ARR_DEP) {
                        let newColor = scaleColorTrafficArriveDepart(d.specificArrivals, d.specificDepartures);
                        animateCell.style("fill", newColor);
                     }
                  })
                  setTimeout(() => { setMarkerAppearanceSelected(selectedStation.bubble) }, 1100);
               }
               
            }
            
            function scaleRadiusTrafficVolume (traffic, maxTraffic = 500) {
               let radiusDomain = Math.max(maxTraffic, 500);
               scaleRadius = d3.scaleSqrt()
                  .domain([0, 1, radiusDomain])
                  .range([0, 3, 20]);
               return scaleRadius(traffic) ;
            }
            
            function scaleRadiusStationTrafficVolume (traffic, maxTraffic = 100) {
               let newRadius = 0
               scaleRadius = d3.scaleSqrt()
                 .domain([0, 1, maxTraffic/5])
                 .range([0, 3, 15]);
               newRadius = Math.min(scaleRadius(traffic), 20);
               return newRadius;
            }
            
            function scaleColorTrafficArriveDepart (arrivals, departures) {
               let newColor = "hsla(0, 0%, 0%, 0.0)";
               scaleColor = d3.scaleLinear()
                  .domain([0, 0.35, 0.65, 1])
                  .range(['darkorange', 'orange', 'blue', 'darkblue']);
               newColor = scaleColor(arrivals*1.0 /(arrivals + departures));
               return newColor;
            }
            
        </script>

</body>

</html>