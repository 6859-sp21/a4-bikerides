<!-- Starter code and data adapted from http://duspviz.mit.edu/d3-workshop/mapping-data-with-d3/ -->
<html>

<head>
    <title>A Basic D3 map</title>
    <!-- <script src="http://d3js.org/d3.v4.js" charset="utf-8"></script> -->
    <script src="https://d3js.org/d3.v6.min.js"></script>

    <script src="data/boston_neighborhoods.json"></script>
    <script src="data/201903-bluebikes-tripdata.csv"></script>
    <script src="process_data.js"></script>

    <script src="https://d3js.org/d3-array.v2.min.js"></script>
    <script src="https://d3js.org/d3-geo.v2.min.js"></script>
    <script src="https://d3js.org/d3-geo-projection.v3.min.js"></script>
    <script src="https://d3js.org/d3-queue.v3.min.js"></script>

    <script src="https://d3js.org/d3-voronoi.v1.min.js"></script>

    <!-- <script src="./d3-simple-slider.js"></script><script src="https://d3js.org/d3.v6.min.js"></script> -->
    <script src="https://unpkg.com/d3-simple-slider"></script>

    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css"
        integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous" />

</head>>

<body>
    <h1>hello</h1>
    <div class="row align-items-center">
        <div class="col-sm-2">
            <p id="value-simple"></p>
        </div>
        <div class="col-sm">
            <div id="slider-simple"></div>
        </div>
    </div>
    <h1>world</h1>

    <script>

        function initializeSlider(timeSliceData) {
            // Simple
            // https://bl.ocks.org/johnwalley/e1d256b81e51da68f7feb632a53c3518
            var data = timeSliceData.map((val, idx)  => idx)
            console.log("slider data: ", data)
            var sliderSimple = d3
                .sliderBottom()
                .min(d3.min(data))
                .max(d3.max(data))
                .width(600)
                .step(1)
                .tickFormat(idx => {
                    console.log("inside tickFormat")
                    console.log(idx)
                    let date = new Date(timeSliceData[idx][0] * 1000)
                    console.log("hours: ",date.getHours())
                    return d3.timeFormat("%I %p")(date)
                })
                .ticks(data.length - 1)
                .default(0)
                .on('onchange', idx => {
                    onSlider(idx)

                    let sumTrips = 0
                    timeSliceData[idx][1].forEach((value, key) => {
                        sumTrips += value
                    })

                    d3.select('p#value-simple').text(sumTrips + " trips.");
                });
    
            var gSimple = d3
                .select('div#slider-simple')
                .append('svg')
                .attr('width', 800)
                .attr('height', 100)
                .append('g')
                .attr('transform', 'translate(30,30)');
    
            gSimple.call(sliderSimple);
    
            d3.select('p#value-simple').text(d3.format('.1')(sliderSimple.value()));
        }
    </script>


    <script>
        // ALL FUNCTION DEFINTIONS

        // Constants
        const TIME_SLICE_DURATION = 120 // in minutes
        const NUM_TRIPS_TO_USE = 20000 // number of trips to use from the dataset
        const NUM_SLICES = 12

        // Global variables
        var stationData, tripsData
        var stationDataMap = new Map()
        var timeSliceData
        var voronoi, voronoiPolys

        function onSlider(val) {
            console.log("Slider changed: ", val)

            let sliceData = timeSliceData[val][1]
            console.log("slider: sliceData ", sliceData)

            d3JoinData(stationData, sliceData, stationDataMap)
        }

        // sliceData: stationID => value map
        function d3JoinData(stationData, sliceData, stationDataMap) {
            console.log("d3JoinData() called.")
            console.log("sliceData: ", sliceData)
            // Voronoi guide: https://observablehq.com/@mbostock/u-s-airports-voronoi

            // Grab heatmap SVG group and set attributes
            var gHeatmap = d3.select("#heatmap")
                .attr("fill", "none")
                // .attr("stroke", "red")
                .attr("pointer-events", "all");

            gHeatmap.selectAll("path")
                .data(voronoiPolys)
                .join(
                    enter => enter
                        .append("path")
                        .attr("d", polygonF)
                        .attr("fill", getStationColor),
                    update => update
                        .attr("fill", getStationColor),
                    exit => exit.remove()
                )

            var maxStationID = 446

            // var minNetIncoming = Math.max(...stationData.map(v => v.netincoming))
            // var maxNetIncoming = Math.min(...stationData.map(v => v.netincoming))
            // console.log("minNetIncoming: ", minNetIncoming)
            // console.log("maxNetIncoming: ", maxNetIncoming)

            function getStationColor(d) {
                // TODO: replace with trip value
                let stationID = d.metadata["station id"]
                let stationData = stationDataMap.get(stationID)
                
                let colorValue = sliceData.get(stationID)
                if (colorValue == null) {
                    colorValue = 0
                }

                let pct = colorValue / 20

                pct = Math.min(pct, 1.0)
                return `hsla(36, ${pct * 100}%, 63%, 0.9)`
            }

            function polygonF(d) {
                d = d.poly
                d = d.filter(v => v != null)

                let p = d.map(v => {
                    return albersProjection([v[1], v[0]])
                })
                return "M" + p.join("L") + "Z";
            }

        }

        function computeStationTraffic(stationData, tripsData) {
            console.log("Computing station traffic...")
            stationData.forEach(function (d) {
                d.arrivals = tripsData.filter(trip => (trip['end station id'] == d['station id'])).length;
                d.departures = tripsData.filter(trip => (trip['start station id'] == d['station id'])).length;
                d.netincoming = d.arrivals - d.departures
            })
            console.log("Done computing station traffic...")
        }

        // Given the a subset of the raw trip-level dataset, calculate aggregate metrics for time slices of the 
        // specified duration
        // @param: sliceDuration - duration of a slice in minutes
        function createTimeSliceData(tripsData, sliceDuration, numSlices) {
            console.log("Calculating time slice data...")

            var sliceDurationSeconds = sliceDuration * 60

            var sliceMap = new Map()

            // unixtime in seconds
            var earliestStartTime = Math.floor(new Date(tripsData[0]["starttime"]).getTime() / 1000)
            var latestEndTime = Math.floor(new Date(tripsData[0]["stoptime"]).getTime() / 1000)

            console.log("earliest: ", earliestStartTime)
            console.log("latest: ", latestEndTime)

            tripsData.forEach(v => {
                let newStarttime = Math.floor(new Date(v["starttime"]).getTime() / 1000)
                let newEndtime = Math.floor(new Date(v["stoptime"]).getTime() / 1000)

                if (newStarttime < earliestStartTime) {
                    earliestStartTime = newStarttime
                }

                if (newEndtime > latestEndTime) {
                    latestEndTime = newEndtime
                }
            })

            for (let i = earliestStartTime; i < latestEndTime; i += sliceDurationSeconds) {
                sliceMap.set(i, { startTime: i, endTime: i + sliceDurationSeconds, tripsStarting: [], tripsEnding: [] })
            }

            sortedTrips = tripsData.sort((a, b) => a["starttime"] < b["starttime"])

            console.log("sorted trips: ", sortedTrips)

            // Bucket each trip into a time slice
            let currentSliceStart = earliestStartTime

            // TODO(bdnwang): bucketing logic is jank, pls fix later
            sortedTrips.forEach(v => {
                let tripStartTime = Math.floor(new Date(v["starttime"]).getTime() / 1000)

                while (tripStartTime > (currentSliceStart + sliceDurationSeconds)) {
                    currentSliceStart += sliceDurationSeconds
                }

                let sliceData = sliceMap.get(currentSliceStart)
                sliceData["tripsStarting"].push(v)
            })

            sortedEndTimeTrips = tripsData.sort((a, b) => a["stoptime"] < b["stoptime"])
            console.log("sortedEndTimeTrips: ", sortedEndTimeTrips)

            currentSliceStart = earliestStartTime
            // TODO: end time trip bucketing gives weirdly clustered bucket assignments. should investigate
            sortedEndTimeTrips.forEach(v => {
                let tripEndTime = Math.floor(new Date(v["stoptime"]).getTime() / 1000)

                while (tripEndTime > (currentSliceStart + sliceDurationSeconds)) {
                    currentSliceStart += sliceDurationSeconds
                }

                let sliceData = sliceMap.get(currentSliceStart)
                sliceData["tripsEnding"].push(v)
            })
            console.log("SLICE MAP: ", sliceMap)

            // Use the sliceData to calculate the per-station values for each time slice
            var finalStationValues = new Map()

            sliceMap.forEach((value, key) => {
                let tripsStarting = value["tripsStarting"]

                let stationValuesForSlice = new Map()
                
                tripsStarting.forEach(v => {
                    let stationID = v["start station id"]
                    let oldValue = stationValuesForSlice.get(stationID)
                    if (oldValue == null) {
                        oldValue = 0
                    }

                    stationValuesForSlice.set(stationID, oldValue + 1)
                })
                
                finalStationValues.set(key, stationValuesForSlice)
            })

            
            finalStationValues = Array.from(finalStationValues, ([key, value]) => [key, value])
            finalStationValues.sort((a,b) => a[0] < b[0])
            
            finalStationValues = finalStationValues.slice(0, numSlices)

            console.log("FINAL STATION VALUES: ", finalStationValues)
            console.log("Done calculating time slice data...")



            return finalStationValues
        }

        function onDataLoad(loadedStationData, loadedTripsData) {
            console.log("ready() called")
            console.log("LOADED TRIPS DATA: ", loadedTripsData)
            // convert stationData to a id -> data map

            loadedStationData.forEach(v => {
                stationDataMap.set(v["station id"], v)
            });
            console.log(stationDataMap)

            var gStations = d3.select("#stations")
                .attr("fill", "none")
                .attr("stroke", "red")
                .attr("pointer-events", "all");

            // Plot station locations
            gStations.selectAll("circle")
                .data(loadedStationData)
                .enter()
                .append('circle')
                .attr("r", 2)
                .attr("transform", function (d) {
                    return "translate(" + albersProjection([d.longitude, d.latitude]) + ")"
                })


            timeSliceData = createTimeSliceData(loadedTripsData.slice(0, NUM_TRIPS_TO_USE), TIME_SLICE_DURATION, NUM_SLICES)
            computeStationTraffic(loadedStationData, loadedTripsData)

            // Voronoi cells
            voronoi = d3.voronoi() //.extent([0,0], [width, height])
            voronoi.x((d) => d.latitude)
            voronoi.y((d) => d.longitude)

            voronoiPolys = voronoi(loadedStationData).polygons()

            voronoiPolys = voronoiPolys.map((v, i) => {
                let metadata = loadedStationData[i]
                return {
                    poly: v,
                    metadata: metadata,
                }
            })

            console.log("voronoiPolys: ", voronoiPolys)

            stationData = loadedStationData
            tripsData = loadedTripsData

            console.log("timeSliceData passed to intiializeSlider: ", timeSliceData)
            initializeSlider(timeSliceData)

            d3JoinData(stationData, timeSliceData[0][1], stationDataMap)
        }


    </script>

    <script>

        console.log("Running javascript.")

        // Set up SVG 'canvas' with Boston map background
        var width = 700;
        var height = 580;

        var svg = d3.select("body")
            .append("svg")
            .attr("width", width)
            .attr("height", height);

        var gMap = svg.append("g")
            .attr("id", "map");

        // Set up other SVG groups now
        svg.append("g")
            .attr("id", "stations")

        svg.append("g")
            .attr("id", "heatmap")

        var albersProjection = d3.geoAlbers()
            .scale(190000)
            .rotate([71.057, 0])
            .center([0, 42.313])
            .translate([width / 2, height / 2]);

        var geoPath = d3.geoPath()
            .projection(albersProjection);

        gMap.selectAll("path")
            .data(neighborhoods_json.features)
            .enter()
            .append("path")
            .attr("fill", "#ccc")
            .attr("stroke", "#333")
            .attr("d", geoPath);

        // Load Bluebike station data asynchronously
        var files = []
        files.push("https://raw.githubusercontent.com/6859-sp21/a4-bikerides/main/bluebikes_2020_stations.csv")
        // files.push("https://raw.githubusercontent.com/6859-sp21/a4-bikerides/main/bluebikes_2020.csv")
        files.push("https://raw.githubusercontent.com/6859-sp21/a4-bikerides/bdnwang-voronoi/data/201909-bluebikes-tripdata.csv")

        var promises = []

        files.forEach(url => {
            promises.push(d3.csv(url))
        })

        Promise.all(promises).then(values => {
            onDataLoad(values[0], values[1])
        })

    </script>
</body>

</html>