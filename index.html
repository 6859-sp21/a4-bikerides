<!-- Starter code and data adapted from http://duspviz.mit.edu/d3-workshop/mapping-data-with-d3/ -->
<html>

<head>
    <title>A Basic D3 map</title>
    <!-- <script src="http://d3js.org/d3.v4.js" charset="utf-8"></script> -->
    <script src="https://d3js.org/d3.v6.min.js"></script>

    <script src="data/boston_neighborhoods.json"></script>
    <script src="data/201903-bluebikes-tripdata.csv"></script>
    <script src="process_data.js"></script>

    <script src="https://d3js.org/d3-array.v2.min.js"></script>
    <script src="https://d3js.org/d3-geo.v2.min.js"></script>
    <script src="https://d3js.org/d3-geo-projection.v3.min.js"></script>
    <script src="https://d3js.org/d3-queue.v3.min.js"></script>

    <script src="https://d3js.org/d3-voronoi.v1.min.js"></script>

    <!-- <script src="./d3-simple-slider.js"></script><script src="https://d3js.org/d3.v6.min.js"></script> -->
    <script src="https://unpkg.com/d3-simple-slider"></script>

    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css"
        integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous" />

</head>>

<body>
    <h1>hello</h1>
    <div class="row align-items-center">
        <div class="col-sm-2">
            <p id="value-simple"></p>
        </div>
        <div class="col-sm">
            <div id="slider-simple"></div>
        </div>
    </div>
    <h1>world</h1>

    <script>
        // Simple
        // https://bl.ocks.org/johnwalley/e1d256b81e51da68f7feb632a53c3518
        var data = [0, 1];

        var sliderSimple = d3
            .sliderBottom()
            .min(d3.min(data))
            .max(d3.max(data))
            .width(300)
            .step(1)
            // .tickFormat(d3.format('.2%'))
            .ticks(data.length - 1)
            .default(0.015)
            .on('onchange', val => {
                onSlider(val)
                d3.select('p#value-simple').text(d3.format('.1')(val));
            });

        var gSimple = d3
            .select('div#slider-simple')
            .append('svg')
            .attr('width', 500)
            .attr('height', 100)
            .append('g')
            .attr('transform', 'translate(30,30)');

        gSimple.call(sliderSimple);

        d3.select('p#value-simple').text(d3.format('.1')(sliderSimple.value()));

    </script>


    <script>
        // ALL FUNCTION DEFINTIONS

        // Global variables
        var stationData, tripsData
        var stationDataMap = new Map()
        var timeSliceData
        var voronoi, voronoiPolys

        function onSlider(val) {
            val = Math.round(val)
            console.log("Slider changed: ", val)

            let tripsForSlice = timeSliceData[val]["tripsStarting"]
            console.log("trips for slice: ", tripsForSlice)

            d3JoinData(stationData, tripsForSlice, stationDataMap)
        }

        function d3JoinData(stationData, tripsData, stationDataMap) {
            console.log("d3JoinData() called.")
            // Voronoi guide: https://observablehq.com/@mbostock/u-s-airports-voronoi

            // Grab heatmap SVG group and set attributes
            var gHeatmap = d3.select("#heatmap")
                .attr("fill", "none")
                .attr("stroke", "red")
                .attr("pointer-events", "all");

            gHeatmap.selectAll("path")
                .data(voronoiPolys)
                .join(
                    enter => enter
                        .append("path")
                        .attr("d", polygonF)
                        .attr("fill", getStationColor),
                    update => update
                        .attr("fill", getStationColor),
                    exit => exit.remove()
                )

            var maxStationID = 446

            // var minNetIncoming = Math.max(...stationData.map(v => v.netincoming))
            // var maxNetIncoming = Math.min(...stationData.map(v => v.netincoming))
            // console.log("minNetIncoming: ", minNetIncoming)
            // console.log("maxNetIncoming: ", maxNetIncoming)

            function getStationColor(d) {
                // TODO: replace with trip value
                let stationID = d.metadata["station id"]
                let stationData = stationDataMap.get(stationID)
                // let colorValue = tripsData.filter(v => v["end station id"] == stationID).length
                let colorValue = tripsData.length
                // console.log("raw color value: ", colorValue)
                // let pct = stationID / 446
                let pct = colorValue / 50

                pct = Math.min(pct, 1.0)
                console.log("pct: ", pct)
                return `hsla(36, ${pct * 100}%, 63%, 0.5)`
            }

            function polygonF(d) {
                d = d.poly
                d = d.filter(v => v != null)

                let p = d.map(v => {
                    return albersProjection([v[1], v[0]])
                })
                return "M" + p.join("L") + "Z";
            }

        }

        function computeStationTraffic(stationData, tripsData) {
            console.log("Computing station traffic...")
            stationData.forEach(function (d) {
                d.arrivals = tripsData.filter(trip => (trip['end station id'] == d['station id'])).length;
                d.departures = tripsData.filter(trip => (trip['start station id'] == d['station id'])).length;
                d.netincoming = d.arrivals - d.departures
            })
            console.log("Done computing station traffic...")
        }

        // Given the a subset of the raw trip-level dataset, calculate aggregate metrics for time slices of the 
        // specified duration
        // @param: sliceDuration - duration of a slice in minutes
        function createTimeSliceData(tripsData, sliceDuration) {
            console.log("Calculating time slice data...")

            var sliceDurationSeconds = sliceDuration * 60

            var sliceMap = new Map()

            // unixtime in seconds
            var earliestStartTime = Math.floor(new Date(tripsData[0]["starttime"]).getTime() / 1000)
            var latestEndTime = Math.floor(new Date(tripsData[0]["stoptime"]).getTime() / 1000)

            console.log("earliest: ", earliestStartTime)
            console.log("latest: ", latestEndTime)

            tripsData.forEach(v => {
                let newStarttime = Math.floor(new Date(v["starttime"]).getTime() / 1000)
                let newEndtime = Math.floor(new Date(v["stoptime"]).getTime() / 1000)

                if (newStarttime < earliestStartTime) {
                    earliestStartTime = newStarttime
                }

                if (newEndtime > latestEndTime) {
                    latestEndTime = newEndtime
                }
            })

            for (let i = earliestStartTime; i < latestEndTime; i += sliceDurationSeconds) {
                sliceMap.set(i, { startTime: i, endTime: i + sliceDurationSeconds, tripsStarting: [], tripsEnding: [] })
            }

            sortedTrips = tripsData.sort((a, b) => a["starttime"] < b["starttime"])

            console.log("sorted trips: ", sortedTrips)

            // Bucket each trip into a time slice
            let currentSliceStart = earliestStartTime

            // TODO(bdnwang): bucketing logic is jank, pls fix later
            sortedTrips.forEach(v => {
                let tripStartTime = Math.floor(new Date(v["starttime"]).getTime() / 1000)

                while (tripStartTime > (currentSliceStart + sliceDurationSeconds)) {
                    currentSliceStart += sliceDurationSeconds
                }

                let sliceData = sliceMap.get(currentSliceStart)
                sliceData["tripsStarting"].push(v)
            })

            sortedEndTimeTrips = tripsData.sort((a, b) => a["stoptime"] < b["stoptime"])
            console.log("sortedEndTimeTrips: ", sortedEndTimeTrips)

            currentSliceStart = earliestStartTime
            // TODO: end time trip bucketing gives weirdly clustered bucket assignments. should investigate
            sortedEndTimeTrips.forEach(v => {
                let tripEndTime = Math.floor(new Date(v["stoptime"]).getTime() / 1000)

                while (tripEndTime > (currentSliceStart + sliceDurationSeconds)) {
                    currentSliceStart += sliceDurationSeconds
                }

                let sliceData = sliceMap.get(currentSliceStart)
                sliceData["tripsEnding"].push(v)
            })
            console.log("SLICE MAP: ", sliceMap)

            sliceArray = Array.from(sliceMap, ([key, value]) => value)

            console.log("Done calculating time slice data...")

            return sliceArray
        }

        function onDataLoad(loadedStationData, loadedTripsData) {
            console.log("ready() called")
            // convert stationData to a id -> data map

            loadedStationData.forEach(v => {
                stationDataMap.set(v["station id"], v)
            });
            console.log(stationDataMap)

            var gStations = d3.select("#stations")
                .attr("fill", "none")
                .attr("stroke", "red")
                .attr("pointer-events", "all");

            // Plot station locations
            gStations.selectAll("circle")
                .data(loadedStationData)
                .enter()
                .append('circle')
                .attr("r", 2)
                .attr("transform", function (d) {
                    return "translate(" + albersProjection([d.longitude, d.latitude]) + ")"
                })


            timeSliceData = createTimeSliceData(loadedTripsData.slice(0, 5000), 120)
            computeStationTraffic(loadedStationData, loadedTripsData)

            // Voronoi cells
            voronoi = d3.voronoi() //.extent([0,0], [width, height])
            voronoi.x((d) => d.latitude)
            voronoi.y((d) => d.longitude)

            voronoiPolys = voronoi(loadedStationData).polygons()

            voronoiPolys = voronoiPolys.map((v, i) => {
                let metadata = loadedStationData[i]
                return {
                    poly: v,
                    metadata: metadata,
                }
            })

            console.log("voronoiPolys: ", voronoiPolys)

            stationData = loadedStationData
            tripsData = loadedTripsData

            d3JoinData(stationData, tripsData, stationDataMap)
        }


    </script>

    <script>

        console.log("Running javascript.")

        // Set up SVG 'canvas' with Boston map background
        var width = 700;
        var height = 580;

        var svg = d3.select("body")
            .append("svg")
            .attr("width", width)
            .attr("height", height);

        var gMap = svg.append("g")
            .attr("id", "map");

        // Set up other SVG groups now
        svg.append("g")
            .attr("id", "stations")

        svg.append("g")
            .attr("id", "heatmap")

        var albersProjection = d3.geoAlbers()
            .scale(190000)
            .rotate([71.057, 0])
            .center([0, 42.313])
            .translate([width / 2, height / 2]);

        var geoPath = d3.geoPath()
            .projection(albersProjection);

        gMap.selectAll("path")
            .data(neighborhoods_json.features)
            .enter()
            .append("path")
            .attr("fill", "#ccc")
            .attr("stroke", "#333")
            .attr("d", geoPath);

        // Load Bluebike station data asynchronously
        var files = []
        files.push("https://raw.githubusercontent.com/6859-sp21/a4-bikerides/main/bluebikes_2020_stations.csv")
        files.push("https://raw.githubusercontent.com/6859-sp21/a4-bikerides/main/bluebikes_2020.csv")

        var promises = []

        files.forEach(url => {
            promises.push(d3.csv(url))
        })

        Promise.all(promises).then(values => {
            onDataLoad(values[0], values[1])
        })

    </script>
</body>

</html>